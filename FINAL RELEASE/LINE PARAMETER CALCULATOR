import numpy as np
import webview
from itertools import combinations, product
import google.generativeai as genai
import json
import tempfile
import subprocess
import os
import shutil
from tkinter import Tk, filedialog
import datetime

GEMINI_API_KEY = "AIzaSyDgJcTZHERGt6URVGdTwd8twOCaumUtX4g"

"""
Transmission Line Parameter Calculator Backend

This script provides the backend logic for a transmission line parameter calculator.
It computes the Geometric Mean Radius (GMR), Geometric Mean Distance (GMD),
and the fundamental line parameters (Resistance, Inductance, Capacitance) for
a three-phase transmission line configuration.

The calculations support bundled conductors and various units of measurement.

Core Components:
- Utility Functions: Handle mathematical operations like distance, geometric mean,
  GMR, and GMD calculations.
- GMDGMRApp Class: An object-oriented approach to manage the state of the
  transmission line, including conductor positions, materials, and other
  physical properties.

-----------------------------
Standalone Usage Example
-----------------------------
The following example demonstrates how to use the GMDGMRApp class to model a
simple three-phase transmission line and calculate its parameters.

if __name__ == '__main__':
    # 1. Initialize the application
    app = GMDGMRApp()

    # 2. Set the units and line parameters
    print(app.set_unit("ft"))  # All coordinates and radii will be in feet
    print(app.set_line_params(material="ACSR", length=150, radius=0.04, freq=60))
    print("-" * 20)

    # 3. Define the self GMR (r') for the conductors in each phase
    # This is often given as 0.7788 * radius for a solid cylindrical wire.
    # For this example, let's use a hypothetical value.
    conductor_gmr_ft = 0.035
    print(app.set_gmr("A", conductor_gmr_ft))
    print(app.set_gmr("B", conductor_gmr_ft))
    print(app.set_gmr("C", conductor_gmr_ft))
    print("-" * 20)

    # 4. Add conductor coordinates for each phase (bundle)
    # Let's model a horizontal configuration with 20 ft spacing.
    # Phase A at (-20, 0)
    # Phase B at (0, 0)
    # Phase C at (20, 0)
    print("Adding points for Phase A...")
    app.add_point(x=-20, y=0, bundle="A")

    print("Adding points for Phase B...")
    app.add_point(x=0, y=0, bundle="B")

    print("Adding points for Phase C...")
    app.add_point(x=20, y=0, bundle="C")
    print("-" * 20)

    # 5. Compute and display the results
    results = app.compute_results()

    print("\\n========== COMPUTATION RESULTS ==========")
    print("--- GMR Values ---")
    for gmr_data in results.get("gmr", []):
        print(f"Phase {gmr_data['label']}: {gmr_data['value']:.6f} meters")

    print("\\n--- GMD Values ---")
    for gmd_data in results.get("gmd", []):
        print(f"{gmd_data['pair']}: {gmd_data['value']:.6f} meters")

    print("\\n--- Line Parameters ---")
    params = results.get("params", {})
    if params:
        print(f"Total Resistance (R): {params['R_total']:.4f} Ω")
        print(f"Total Inductance (L): {params['L_total']:.4f} mH")
        print(f"Total Capacitance (C): {params['C_total']:.4f} µF")
        print(f"Inductive Reactance (XL): {params['XL']:.4f} Ω")
        print(f"Capacitive Reactance (XC): {params['XC']:.4f} Ω")
    print("========================================")

"""

# ---------- Unit Conversion ----------
UNIT_CONVERSIONS = {
    "m": 1.0,
    "ft": 0.3048,
    "inch": 0.0254,
    "cm": 0.01,
    "mm": 0.001
}

# Material resistivity at 20°C (Ω·m)
MATERIALS = {
    "Copper": 1.68e-8,
    "Aluminum": 2.82e-8,
    "Steel": 1.43e-7,
    "ACSR": 3.2e-8
}

# ---------- Math Utilities ----------
def distance(p1, p2):
    """Calculates the Euclidean distance between two points.

    Args:
        p1 (tuple): A tuple (x, y) representing the first point.
        p2 (tuple): A tuple (x, y) representing the second point.

    Returns:
        float: The distance between p1 and p2.
    """
    return np.linalg.norm(np.array(p1) - np.array(p2))

def geometric_mean(values):
    """Calculates the geometric mean of a list of numbers.

    Args:
        values (list of float): A list of numerical values.

    Returns:
        float: The geometric mean of the values.
    """
    if not values:
        return 1.0  # Return 1 for empty product to avoid errors
    return np.prod(values) ** (1 / len(values))

def compute_gmr(bundle_points, r_self):
    """Computes the Geometric Mean Radius (GMR) for a bundled conductor.
    Also known as self GMD (Ds).

    Args:
        bundle_points (list of tuples): A list of (x, y) coordinates for each
                                        conductor within the bundle.
        r_self (float): The self GMR of a single conductor, often denoted as r'
                        (r' = 0.7788 * radius for a solid wire). Must be in meters.

    Returns:
        float: The calculated GMR of the bundle in meters.
    """
    n = len(bundle_points)
    if n == 1:
        return r_self
    # Distances between every unique pair of conductors in the bundle
    distances = [distance(p1, p2) for p1, p2 in combinations(bundle_points, 2)]
    # The GMR formula involves n^2 terms in the root.
    # This includes n terms of r_self and n*(n-1) distances between conductors
    # (with each distance counted twice, D_12 and D_21).
    # This simplified version uses each unique distance twice.
    num_terms = n**2
    
    prod_distances = np.prod(distances)
    if prod_distances == 0:
        # Handle case where points are co-located
        return r_self 
        
    all_terms_product = (r_self**n) * (prod_distances**2)
    
    if all_terms_product <= 0:
         # Avoid log(0) or root of negative number
        return r_self

    gmr = all_terms_product**(1 / num_terms)
    return gmr


def compute_gmd(bundle1, bundle2):
    """Computes the Geometric Mean Distance (GMD) between two conductor bundles.
    Also known as mutual GMD.

    Args:
        bundle1 (list of tuples): List of (x, y) coordinates for conductors in the first bundle.
        bundle2 (list of tuples): List of (x, y) coordinates for conductors in the second bundle.

    Returns:
        float: The calculated GMD between the two bundles in meters.
    """
    distances = [distance(p1, p2) for p1, p2 in product(bundle1, bundle2)]
    if not distances:
        return 1.0
    return geometric_mean(distances)

# ---------- App Logic ----------
class GMDGMRApp:
    """Manages the state and calculations for the transmission line calculator."""
    def __init__(self):
        """Initializes the GMDGMRApp with default values."""
        self.bundles = {"A": [], "B": [], "C": []}
        # Initialize with 0.7788 * default radius for solid conductors
        self.r_self = {"A": 0.01 * 0.7788, "B": 0.01 * 0.7788, "C": 0.01 * 0.7788}
        self.unit = "m"
        self.scale_x = 40
        self.scale_y = 40
        
        # Line parameters
        self.material = "Copper"
        self.length = 100.0  # km
        self.conductor_radius = 0.01  # m
        self.freq = 60.0  # Hz

    def set_unit(self, u):
        """Sets the default unit for all incoming spatial measurements.

        Args:
            u (str): The unit to use ('m', 'ft', 'inch', 'cm', 'mm').

        Returns:
            str: A confirmation message.
        """
        if u in UNIT_CONVERSIONS:
            self.unit = u
        return f"Units set to {u}"

    def set_scale(self, sx, sy):
        """Sets the UI canvas scaling factors (for visualization).

        Args:
            sx (float): The scale factor for the x-axis.
            sy (float): The scale factor for the y-axis.

        Returns:
            str: A confirmation message.
        """
        self.scale_x = float(sx)
        self.scale_y = float(sy)
        return "Scales updated"

    def set_gmr(self, bundle, val):
        """Sets the self GMR (r') for conductors of a given phase/bundle.

        Args:
            bundle (str): The bundle label ('A', 'B', or 'C').
            val (float): The numerical value of the *radius* in the current units.

        Returns:
            str: A confirmation message.
        """
        # The user inputs the *radius*, and we calculate r'
        gmr_value = float(val) * 0.7788 * UNIT_CONVERSIONS[self.unit]
        self.r_self[bundle] = gmr_value
        return f"Set GMR for {bundle} = {val} {self.unit} (r' = {gmr_value:.6f} m)"

    def set_line_params(self, material, length, radius, freq):
        """Sets the physical parameters of the transmission line.

        Args:
            material (str): The conductor material ("Copper", "Aluminum", etc.).
            length (float): The total length of the line in kilometers.
            radius (float): The physical radius of a single conductor in meters.
            freq (float): The system frequency in Hertz.

        Returns:
            str: A confirmation message.
        """
        self.material = material
        self.length = float(length)
        self.conductor_radius = float(radius)
        self.freq = float(freq)
        
        # Also update the GMR values based on the new radius
        for bundle in self.r_self:
            self.r_self[bundle] = self.conductor_radius * 0.7788
            
        return "Parameters updated"

    def add_point(self, x, y, bundle):
        """Adds a conductor's coordinate to a specific bundle/phase.

        Args:
            x (float): The x-coordinate of the conductor in the current units.
            y (float): The y-coordinate of the conductor in the current units.
            bundle (str): The bundle label to add the point to ('A', 'B', or 'C').

        Returns:
            str: "ok" on success.
        """
        x_m = float(x) * UNIT_CONVERSIONS[self.unit]
        y_m = float(y) * UNIT_CONVERSIONS[self.unit]
        self.bundles[bundle].append((x_m, y_m))
        return "ok"

    def clear_bundle(self, bundle):
        """Clears all conductor points from a single bundle.

        Args:
            bundle (str): The bundle label to clear ('A', 'B', or 'C').

        Returns:
            str: A confirmation message.
        """
        self.bundles[bundle] = []
        return f"Cleared {bundle}"

    def clear_all(self):
        """Clears all conductor points from all bundles."""
        self.bundles = {"A": [], "B": [], "C": []}
        return "All cleared"

    def compute_results(self):
        """Performs all major calculations for the defined transmission line.

        Calculates GMR for each bundle, GMD between each pair of bundles,
        and the R, L, C line parameters based on the stored configuration.

        Returns:
            dict: A dictionary containing the results, structured as:
            {
                "gmr": [{"label": "A", "value": 0.01, "count": 1}, ...],
                "gmd": [{"pair": "A-B", "value": 1.0}, ...],
                "params": {
                    "R_total": ...,
                    "L_total": ... (mH),
                    "C_total": ... (µF),
                    "XL": ...,
                    "XC": ...
                }
            }
        """
        results = {"gmr": [], "gmd": [], "params": {}}
        gmr_values = {}
        
        # GMR calculations
        for label, points in self.bundles.items():
            if points:
                r_prime_bundle = self.r_self[label]
                gmr_values[label] = compute_gmr(points, r_prime_bundle)
                results["gmr"].append({
                    "label": label,
                    "value": gmr_values[label],
                    "count": len(points)
                })
        
        # GMD calculations
        gmd_values = {}
        for (a, b) in combinations(self.bundles.keys(), 2):
            if self.bundles[a] and self.bundles[b]:
                gmd = compute_gmd(self.bundles[a], self.bundles[b])
                gmd_values[f"{a}-{b}"] = gmd
                results["gmd"].append({
                    "pair": f"{a}-{b}",
                    "value": gmd
                })
        
        # Parameter calculations (3-phase assumed)
        if len(gmr_values) >= 1:
            # Resistance (Ω/km)
            rho = MATERIALS.get(self.material, 1.68e-8)
            area = np.pi * (self.conductor_radius ** 2)
            
            # n_conductors is the number of conductors *per phase/bundle*
            # We assume all bundles have the same number of conductors
            n_conductors = 1
            if gmr_values:
                 first_bundle_label = list(gmr_values.keys())[0]
                 n_conductors = len(self.bundles[first_bundle_label])
            
            if n_conductors == 0: n_conductors = 1 # Avoid division by zero
            
            R_per_km = (rho * 1000) / (area * n_conductors)
            R_total = R_per_km * self.length
            
            L_per_km = 0
            L_total = 0
            C_per_km = 0
            C_total = 0
            avg_gmd = 1.0
            avg_gmr = 1.0
            r_bundle_equiv = self.conductor_radius

            # Inductance (H/km and H total)
            if len(gmr_values) >= 2: # Need at least 2 phases for GMD
                avg_gmd = np.mean(list(gmd_values.values())) if gmd_values else 1.0
                avg_gmr = np.mean(list(gmr_values.values()))
                
                if avg_gmd > 0 and avg_gmr > 0 and (avg_gmd / avg_gmr) > 0:
                   L_per_km = 2e-7 * np.log(avg_gmd / avg_gmr) * 1000  # H/km
                   L_total = L_per_km * self.length
            
            # Capacitance (F/km and F total)
            if len(gmr_values) >= 2:
                # For capacitance, we use the actual conductor radius, not GMR.
                # An equivalent bundle radius (r_b) is needed.
                
                first_bundle_label = list(gmr_values.keys())[0]
                bundle_points = self.bundles[first_bundle_label]
                
                if n_conductors > 1:
                    bundle_distances = [distance(p1,p2) for p1,p2 in combinations(bundle_points, 2)]
                    
                    if bundle_distances:
                        prod_distances_sq = (np.prod(bundle_distances))**2
                        r_bundle_equiv = ( (self.conductor_radius**n) * prod_distances_sq )**(1/n**2)
                    else:
                        # This can happen if points are co-located
                        r_bundle_equiv = self.conductor_radius
                else:
                    r_bundle_equiv = self.conductor_radius

                if avg_gmd > 0 and r_bundle_equiv > 0 and (avg_gmd / r_bundle_equiv) > 0:
                   C_per_km = (2 * np.pi * 8.854e-12 * 1000) / np.log(avg_gmd / r_bundle_equiv) # F/km
                   C_total = C_per_km * self.length
            
            # Reactances
            omega = 2 * np.pi * self.freq
            XL = omega * L_total if L_total > 0 else 0
            XC = (1 / (omega * C_total)) if C_total > 0 else 0
            
            results["params"] = {
                "R_per_km": R_per_km,
                "R_total": R_total,
                "L_per_km": L_per_km * 1000,  # mH/km
                "L_total": L_total * 1000,  # mH
                "C_per_km": C_per_km * 1e9,  # nF/km
                "C_total": C_total * 1e6,  # µF
                "XL": XL,
                "XC": XC
            }
        
        return results
        
    def export_latex_solution(self, api_key=None):
        """Generates a detailed LaTeX solution document using Gemini API.
        
        Args:
            api_key (str): Google Gemini API key (optional if GEMINI_API_KEY is set)
            
        Returns:
            str: LaTeX document content or error message
        """
        try:
            # Use provided key or fall back to constant
            key = api_key if api_key else GEMINI_API_KEY
            
            if not key:
                return "Error: No API key provided"
            
            # Configure Gemini
            genai.configure(api_key=key)
            model = genai.GenerativeModel('gemini-1.5-flash') # Use 'gemini-1.5-flash'
            
            # Get current results
            results = self.compute_results()
            
            # Check if there's data to export
            if not any(self.bundles.values()):
                return "Error: No conductor data to export. Please add some points first."
            
            # Create detailed prompt for Gemini
            prompt = f"""You are a LaTeX document generator for transmission line parameter calculations with expertise in coordinate rectification. Create a complete, professionally formatted LaTeX document with the following data:

INPUT DATA:
Material: {self.material}
Line Length: {self.length} km
Conductor Radius: {self.conductor_radius} m
Frequency: {self.freq} Hz
Units: {self.unit}

Bundle Configuration (meters):
{json.dumps({k: v for k, v in self.bundles.items() if v}, indent=2)}

Self GMR (r') Values (meters):
{json.dumps(self.r_self, indent=2)}

Calculation Results:
{json.dumps(results, indent=2)}

REQUIRED DOCUMENT SECTIONS:
1. Title: "Transmission Line Parameter Calculation"
2. Problem Statement
3. Conductor Configuration Analysis
   - Original coordinate plot using TikZ
   - Coordinate accuracy analysis
   - Rectified coordinates based on standard transmission line patterns
4. Step-by-step Calculations
   - GMR/GMD using original coordinates
   - GMR/GMD using rectified coordinates (if significant discrepancies found)
   - Analysis of differences between original and rectified values
5. Derivation of RLC Parameters
   - Calculations using original coordinates
   - Calculations using rectified coordinates (if applicable)
   - Impact analysis of coordinate rectification on final results
6. Results Summary
   - Comparative table showing original vs. rectified results
   - Percentage differences and engineering significance
   - Recommendations based on the analysis

COORDINATE RECTIFICATION GUIDELINES:
- Analyze coordinate patterns for standard transmission line configurations
- Check for small deviations (0.001-0.01m) from expected symmetrical patterns
- Identify and correct potential human input errors
- Consider standard spacing patterns in transmission line design
- Document assumptions made during rectification

FORMATTING REQUIREMENTS:
- Use article class with amsmath, geometry, booktabs, tikz, babel[english], fontspec, fancyhdr, hyperref
- Set Inter as main font
- Right header: "Generated by the BCMSV GMR/GMD Line Parameters Calculator Application, 2025-20256 from BSEE-4A"
- A4 paper with 2.5cm top/bottom margins, 2cm left/right margins
- Number all equations
- Include side-by-side TikZ plots showing original vs. rectified coordinates
- Use booktabs for professional comparison tables
- Use color coding in plots to highlight rectified points

Generate LaTeX code that can be directly compiled with pdflatex. Ensure the document clearly explains any rectification decisions and their impact on the final results."""

            # Generate LaTeX
            response = model.generate_content(prompt)
            
            latex_content = response.text
            
            # Clean up markdown code blocks if present
            if "```latex" in latex_content:
                latex_content = latex_content.split("```latex")[1].split("```")[0].strip()
            elif "```tex" in latex_content:
                latex_content = latex_content.split("```tex")[1].split("```")[0].strip()
            elif "```" in latex_content:
                parts = latex_content.split("```")
                if len(parts) > 1:
                    latex_content = parts[1]
                    # Remove potential language specifier like 'latex' or 'tex'
                    if latex_content.startswith('latex'):
                        latex_content = latex_content[5:].strip()
                    elif latex_content.startswith('tex'):
                        latex_content = latex_content[3:].strip()
                else:
                    latex_content = parts[0] # No code block found, use whole text
            
            return latex_content
            
        except Exception as e:
            return f"Error generating LaTeX: {str(e)}"

    def generate_pdf_from_latex(self, latex_content):
        """Generates a PDF from LaTeX content using pdflatex.
        
        Args:
            latex_content (str): The LaTeX document content
            
        Returns:
            dict: {'success': bool, 'path': str, 'error': str}
        """
        try:
            # Create temporary directory for LaTeX compilation
            with tempfile.TemporaryDirectory() as tmpdir:
                # Write LaTeX content to file
                tex_file = os.path.join(tmpdir, 'solution.tex')
                with open(tex_file, 'w', encoding='utf-8') as f:
                    f.write(latex_content)
                
                pdf_file = os.path.join(tmpdir, 'solution.pdf')
                
                # Try to find pdflatex
                pdflatex_cmd = 'pdflatex'
                if not shutil.which(pdflatex_cmd):
                    return {
                        'success': False,
                        'error': 'pdflatex not found. Please install a LaTeX distribution (like TeX Live, MiKTeX, or MacTeX) and ensure it is in your system PATH.'
                    }

                # Compile LaTeX to PDF (run twice for proper references)
                for _ in range(2):
                    result = subprocess.run(
                        [pdflatex_cmd, '-interaction=nonstopmode', '-output-directory', tmpdir, tex_file],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )
                
                if not os.path.exists(pdf_file):
                    log_snippet = (result.stdout or "")[-1000:] + (result.stderr or "")[-1000:]
                    return {
                        'success': False,
                        'error': f"PDF compilation failed. Check LaTeX code for errors. Log snippet: {log_snippet}"
                    }
                
                # Open save dialog
                root = Tk()
                root.withdraw()
                root.attributes('-topmost', True)
                
                timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                default_filename = f'transmission_line_solution_{timestamp}.pdf'
                
                save_path = filedialog.asksaveasfilename(
                    defaultextension='.pdf',
                    filetypes=[('PDF files', '*.pdf'), ('All files', '*.*')],
                    initialfile=default_filename,
                    title='Save PDF Solution'
                )
                
                root.destroy()
                
                if save_path:
                    # Copy PDF to selected location
                    shutil.copy2(pdf_file, save_path)
                    
                    return {
                        'success': True,
                        'path': save_path
                    }
                else:
                    return {
                        'success': False,
                        'error': 'Save cancelled by user'
                    }
                    
        except FileNotFoundError:
            return {
                'success': False,
                'error': 'pdflatex not found. Please install LaTeX (TeX Live, MiKTeX, or MacTeX).'
            }
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'PDF compilation timed out.'
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
# ---------- Modern Windows-Style UI ----------
html = """
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Transmission Line Calculator</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --bg: #f3f3f3;
  --panel: #ffffff;
  --panel-dark: #fafafa;
  --fg: #1f1f1f;
  --fg-secondary: #605e5c;
  --accent: #0078d4;
  --accent-hover: #106ebe;
  --accent-pressed: #005a9e;
  --border: #e1dfdd;
  --shadow-sm: 0 1.6px 3.6px rgba(0,0,0,.13), 0 0.3px 0.9px rgba(0,0,0,.11);
  --shadow-md: 0 3.2px 7.2px rgba(0,0,0,.13), 0 0.6px 1.8px rgba(0,0,0,.11);
  --shadow-lg: 0 6.4px 14.4px rgba(0,0,0,.13), 0 1.2px 3.6px rgba(0,0,0,.11);
  --radius: 4px;
  --radius-lg: 8px;
}

* { 
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--fg);
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
}

/* --- NEW: Resizer Styles --- */
.resizer {
  width: 5px;
  background: var(--border);
  cursor: col-resize;
  transition: background 0.2s;
  flex-shrink: 0;
  z-index: 50;
}
.resizer:hover {
  background: var(--accent);
}
/* Apply resizing cursor to body to prevent losing cursor style */
body.resizing {
  cursor: col-resize !important;
  user-select: none !important;
}

/* Title Bar */
.titlebar {
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  box-shadow: var(--shadow-sm);
  z-index: 100;
  flex-shrink: 0; /* --- ADDED --- */
}

.titlebar-icon {
  width: 20px;
  height: 20px;
  color: var(--accent);
}

.titlebar-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--fg);
  letter-spacing: -0.01em;
}

/* Main Layout */
.app-container {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Left Sidebar - INCREASED WIDTH */
.sidebar {
  width: 420px; /* Increased from 320px */
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  flex-shrink: 0; /* --- ADDED --- */
}

.sidebar-section {
  padding: 24px; /* Increased from 20px */
  border-bottom: 1px solid var(--border);
}

.sidebar-section:last-child {
  border-bottom: none;
}

.section-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--fg-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 18px; /* Increased from 16px */
}

.form-group {
  margin-bottom: 18px; /* Increased from 16px */
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-label {
  display: block;
  font-size: 13px;
  font-weight: 500;
  color: var(--fg);
  margin-bottom: 8px; /* Increased from 6px */
}

.form-control {
  width: 100%;
  padding: 10px 12px; /* Increased from 8px 10px */
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 13px;
  background: var(--panel);
  color: var(--fg);
  transition: all 0.15s ease;
}

.form-control:hover {
  border-color: #bdbdbd;
}

.form-control:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px var(--accent);
}

.form-row {
  display: flex;
  gap: 12px; /* Increased from 10px */
}

.form-row .form-group {
  flex: 1;
}

/* Buttons */
.btn {
  padding: 10px 18px; /* Increased from 8px 16px */
  border: none;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn-primary {
  background: var(--accent);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover);
}

.btn-primary:active {
  background: var(--accent-pressed);
}

.btn-secondary {
  background: var(--panel-dark);
  color: var(--fg);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  background: #f5f5f5;
}

.btn-danger {
  background: #d13438;
  color: white;
}

.btn-danger:hover {
  background: #a72828;
}

.btn-sm {
  padding: 8px 14px; /* Increased from 6px 12px */
  font-size: 12px;
}

.btn-block {
  width: 100%;
}

/* Bundle Selector */
.bundle-selector {
  display: flex;
  gap: 10px; /* Increased from 8px */
  margin-bottom: 18px; /* Increased from 16px */
}

.bundle-btn {
  flex: 1;
  padding: 12px; /* Increased from 10px */
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--panel);
  color: var(--fg);
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.bundle-btn:hover {
  border-color: #bdbdbd;
}

.bundle-btn.active {
  border-color: var(--accent);
  background: rgba(0, 120, 212, 0.05);
  color: var(--accent);
}

.bundle-btn[data-bundle="A"].active {
  border-color: #d83b01;
  color: #d83b01;
  background: rgba(216, 59, 1, 0.05);
}

.bundle-btn[data-bundle="B"].active {
  border-color: #0078d4;
  color: #0078d4;
  background: rgba(0, 120, 212, 0.05);
}

.bundle-btn[data-bundle="C"].active {
  border-color: #107c10;
  color: #107c10;
  background: rgba(16, 124, 16, 0.05);
}

/* Canvas Area */
.canvas-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--panel-dark);
  /* --- NEW: Ensure canvas can shrink --- */
  min-width: 300px;
}

.canvas-toolbar {
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: var(--panel-dark);
  border-radius: var(--radius);
  border: 1px solid var(--border);
}

.toolbar-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--fg-secondary);
}

.toolbar-input {
  width: 60px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 12px;
  background: var(--panel);
}

.canvas-wrapper {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
  position: relative;
  overflow: hidden; /* --- ADDED --- */
}

canvas {
  background: white;
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  cursor: crosshair;
}

.coord-display {
  position: absolute;
  bottom: 32px;
  left: 32px;
  background: rgba(0, 0, 0, 0.85);
  color: white;
  padding: 8px 14px;
  border-radius: var(--radius);
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
  box-shadow: var(--shadow-md);
  z-index: 20; /* --- ADDED --- */
}

.canvas-legend {
  position: absolute;
  top: 32px;
  right: 32px;
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 14px;
  box-shadow: var(--shadow-md);
  z-index: 20; /* --- ADDED --- */
}

.legend-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--fg-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 13px;
}

.legend-item:last-child {
  margin-bottom: 0;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

/* Right Panel */
.results-panel {
  width: 400px;
  background: var(--panel);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  flex-shrink: 0; /* --- ADDED --- */
}

.results-header {
  padding: 16px 20px;
  background: var(--panel-dark);
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 13px;
  color: var(--fg-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  flex-shrink: 0; /* --- ADDED --- */
}

.results-content {
  padding: 20px;
  flex: 1;
  overflow-y: auto; /* --- ADDED --- */
}

.result-card {
  background: var(--panel-dark);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 16px;
  margin-bottom: 16px;
}

.result-card-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--fg);
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.result-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 0;
  border-bottom: 1px solid #f0f0f0;
}

.result-item:last-child {
  border-bottom: none;
  padding-bottom: 0;
}

.result-label {
  font-size: 13px;
  color: var(--fg-secondary);
  display: flex;
  align-items: center;
  gap: 6px;
}

.result-value {
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 13px;
  font-weight: 600;
  color: var(--fg);
}

.bundle-badge {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}

.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--fg-secondary);
}

.empty-icon {
  width: 48px;
  height: 48px;
  margin: 0 auto 16px;
  opacity: 0.3;
}

.empty-text {
  font-size: 14px;
  line-height: 1.5;
}

/* Parameter Result Highlights */
.param-highlight {
  background: linear-gradient(135deg, rgba(0,120,212,0.05) 0%, rgba(16,124,16,0.05) 100%);
  padding: 12px;
  border-radius: var(--radius);
  border-left: 3px solid var(--accent);
}

.param-highlight .result-value {
  color: var(--accent);
  font-size: 14px;
}

/* --- NEW: Modal Animations --- */
@keyframes spin {
  to { transform: rotate(360deg); }
}
@keyframes modalFadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}
@keyframes modalFadeOut {
  from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(0.9); }
}
</style>
</head>
<body>

<div class="titlebar">
  <svg class="titlebar-icon" fill="currentColor" viewBox="0 0 20 20">
    <path d="M13 7H7v6h6V7z"/>
    <path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 010-2h1V5a2 2 0 012-2h2V2zM5 5h10v10H5V5z" clip-rule="evenodd"/>
  </svg>
  <span class="titlebar-title">Transmission Line Parameter Calculator</span>
</div>

<div class="app-container">
  
  <div class="sidebar" id="leftPanel">
    
    <div class="sidebar-section">
      <div class="section-title">Active Bundle</div>
      <div class="bundle-selector">
        <button class="bundle-btn active" data-bundle="A" onclick="setActiveBundle('A')">A</button>
        <button class="bundle-btn" data-bundle="B" onclick="setActiveBundle('B')">B</button>
        <button class="bundle-btn" data-bundle="C" onclick="setActiveBundle('C')">C</button>
      </div>
      
      <div class="form-row" style="margin-top: 12px;">
        <button class="btn btn-danger btn-sm btn-block" onclick="clearCurrent()">Clear Bundle</button>
        <button class="btn btn-danger btn-sm btn-block" onclick="clearAll()">Clear All</button>
      </div>
    </div>
    
    <div class="sidebar-section">
      <div class="section-title">Geometry Settings</div>
      
      <div class="form-group">
        <label class="form-label">Distance Units</label>
        <select id="unit" class="form-control" onchange="updateUnit()">
          <option value="m">Meters (m)</option>
          <option value="ft">Feet (ft)</option>
          <option value="inch">Inches (in)</option>
          <option value="cm">Centimeters (cm)</option>
          <option value="mm">Millimeters (mm)</option>
        </select>
      </div>
      
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Radius A (in Units)</label>
          <input id="gA" type="number" step="0.001" value="0.01" class="form-control">
        </div>
        <div class="form-group">
          <label class="form-label">Radius B (in Units)</label>
          <input id="gB" type="number" step="0.001" value="0.01" class="form-control">
        </div>
        <div class="form-group">
          <label class="form-label">Radius C (in Units)</label>
          <input id="gC" type="number" step="0.001" value="0.01" class="form-control">
        </div>
      </div>

      <div style="font-size: 11px; color: var(--fg-secondary); margin-bottom: 12px; font-style: italic;">
         Note! GMR (r') automatically calculated as 0.7788 × radius.
      </div>
      
      <button class="btn btn-primary btn-sm btn-block" onclick="setGMRs()">Apply Radii</button>
    </div>
    
    <div class="sidebar-section">
      <div class="section-title">Line Parameters</div>
      
      <div class="form-group">
        <label class="form-label">Material</label>
        <select id="material" class="form-control">
          <option value="Copper">Copper</option>
          <option value="Aluminum">Aluminum</option>
          <option value="Steel">Steel</option>
          <option value="ACSR">ACSR</option>
        </select>
      </div>
      
      <div class="form-group">
        <label class="form-label">Line Length (km)</label>
        <input id="length" type="number" step="0.1" value="100" class="form-control">
      </div>
      
      <div class="form-group">
        <label class="form-label">Conductor Radius (m)</label>
        <input id="radius" type="number" step="0.001" value="0.01" class="form-control">
      </div>
      
      <div class="form-group">
        <label class="form-label">Frequency (Hz)</label>
        <input id="freq" type="number" step="0.1" value="60" class="form-control">
      </div>
      
      <button class="btn btn-primary btn-block" onclick="updateLineParams()">Calculate Parameters</button>
    </div>
    
    <div class="sidebar-section">
      <div class="section-title">Export Solution</div>
      
      <div class="form-group">
        <label class="form-label">Gemini API Key</label>
        <input id="apiKey" type="password" placeholder="Enter API key" class="form-control">
      </div>
      
      <button class="btn btn-primary btn-block" onclick="exportLatex()">
        Generate LaTeX Solution
      </button>
      
      <div id="exportStatus" style="margin-top: 10px; font-size: 12px; color: var(--fg-secondary);"></div>
    </div>
    
  </div>
  
  <div class="resizer" id="leftResizer"></div>
  
  <div class="canvas-area">
    
    <div class="canvas-toolbar">
      <div class="toolbar-group">
        <span class="toolbar-label">Scale X:</span>
        <input id="scaleX" type="number" value="40" class="toolbar-input">
        <span class="toolbar-label">Y:</span>
        <input id="scaleY" type="number" value="40" class="toolbar-input">
        <button class="btn btn-secondary btn-sm" onclick="updateScale()">Apply</button>
      </div>
      
      <div style="margin-left: auto; font-size: 12px; color: var(--fg-secondary);">
        Click to place • SHIFT for 90° • TAB for length/angle • ESC to clear
      </div>
    </div>
    
    <div class="canvas-wrapper">
      <canvas id="plane" width="1000" height="700"></canvas>
      <div class="coord-display" id="coordDisplay">x: 0.000, y: 0.000</div>
      
      <div class="canvas-legend">
        <div class="legend-title">Bundles</div>
        <div class="legend-item">
          <div class="legend-color" style="background: #d83b01;"></div>
          <span>Bundle A</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #0078d4;"></div>
          <span>Bundle B</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #107c10;"></div>
          <span>Bundle C</span>
        </div>
      </div>
    </div>
    
  </div>
  
  <div class="resizer" id="rightResizer"></div>
  
  <div class="results-panel" id="rightPanel">
    <div class="results-header">Calculation Results</div>
    <div class="results-content" id="results">
      <div class="empty-state">
        <svg class="empty-icon" fill="currentColor" viewBox="0 0 20 20">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12z"/>
        </svg>
        <p class="empty-text">Click on the canvas to place conductor points and see calculations</p>
      </div>
    </div>
  </div>
  
</div>

<script>
const canvas = document.getElementById('plane');
const ctx = canvas.getContext('2d');
const colors = {A: '#d83b01', B: '#0078d4', C: '#107c10'};
let bundles = {A: [], B: [], C: []};
let activeBundle = 'A';
let scaleX = 40, scaleY = 40;
const origin = {x: 80, y: canvas.height - 80};

// ===== Snap & Preview System =====
const SNAP_RADIUS = 15;
const SNAP_COLOR = "#FFB900";
let snapPoint = null;
let allPoints = [];
let lastPlacedPoint = null;
let mousePos = {x: 0, y: 0};
let shiftKeyPressed = false;
let referencePoint = null; // Tracks if first point was from another bundle

// Track keyboard state
let inputDialog = null;

window.addEventListener('keydown', (e) => {
  // --- NEW: Prevent key actions if typing in an input ---
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  if (e.key === 'Shift') shiftKeyPressed = true;
  
  // TAB to open input dialog for direct length input
  if (e.key === 'Tab' && lastPlacedPoint) {
    e.preventDefault();
    openLengthInputDialog();
  }
  
  // ESC key to clear pointer and restart
  if (e.key === 'Escape') {
    lastPlacedPoint = null;
    snapPoint = null;
    mousePos = {x: 0, y: 0};
    redraw();
    
    const display = document.getElementById('coordDisplay');
    display.textContent = 'Pointer cleared • Ready for new bundle';
    display.style.background = 'rgba(16, 124, 16, 0.9)';
    display.style.opacity = '1';
    
    setTimeout(() => {
      display.style.opacity = '0';
    }, 2000);
  }
});

window.addEventListener('keyup', (e) => {
  if (e.key === 'Shift') shiftKeyPressed = false;
});

function openLengthInputDialog() {
  if (inputDialog) return; // Prevent multiple dialogs
  
  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'input-overlay';
  overlay.style.cssText = \`
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  \`;
  
  // Create dialog
  const dialog = document.createElement('div');
  dialog.style.cssText = \`
    background: white;
    border-radius: 8px;
    padding: 24px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    min-width: 300px;
    font-family: Inter, sans-serif;
  \`;
  
  dialog.innerHTML = \`
    <div style="margin-bottom: 16px;">
      <h3 style="font-size: 16px; font-weight: 600; color: #1f1f1f; margin-bottom: 8px;">Enter Line Parameters</h3>
    </div>
    
    <div style="margin-bottom: 16px;">
      <label style="display: block; font-size: 13px; font-weight: 500; color: #1f1f1f; margin-bottom: 6px;">Length (in \${document.getElementById('unit').value})</label>
      <input 
        id="length-input" 
        type="number" 
        step="0.001" 
        placeholder="Enter distance"
        style="
          width: 100%;
          padding: 8px 10px;
          border: 1px solid #e1dfdd;
          border-radius: 4px;
          font-size: 13px;
          font-family: Consolas, Monaco, monospace;
          box-sizing: border-box;
        "
      >
    </div>
    
    <div style="margin-bottom: 16px;">
      <label style="display: block; font-size: 13px; font-weight: 500; color: #1f1f1f; margin-bottom: 6px;">Angle (degrees)</label>
      <input 
        id="angle-input" 
        type="number" 
        step="0.1" 
        value="0"
        placeholder="0 to 360"
        style="
          width: 100%;
          padding: 8px 10px;
          border: 1px solid #e1dfdd;
          border-radius: 4px;
          font-size: 13px;
          font-family: Consolas, Monaco, monospace;
          box-sizing: border-box;
        "
      >
      <p style="font-size: 11px; color: #605e5c; margin: 6px 0 0 0;">0° = Right, 90° = Up, 180° = Left, 270° = Down</p>
    </div>
    
    <div style="display: flex; gap: 10px;">
      <button id="confirm-btn" style="
        flex: 1;
        padding: 8px 16px;
        background: #0078d4;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
      ">Place Point</button>
      <button id="cancel-btn" style="
        flex: 1;
        padding: 8px 16px;
        background: #fafafa;
        color: #1f1f1f;
        border: 1px solid #e1dfdd;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
      ">Cancel</button>
    </div>
  \`;
  
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);
  
  const lengthInput = document.getElementById('length-input');
  const angleInput = document.getElementById('angle-input');
  const confirmBtn = document.getElementById('confirm-btn');
  const cancelBtn = document.getElementById('cancel-btn');
  
  // Calculate angle based on current mouse position
  const dx = mousePos.x - lastPlacedPoint.x;
  const dy = lastPlacedPoint.y - mousePos.y; // Flip Y for standard angle measurement
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  const normalizedAngle = angle < 0 ? angle + 360 : angle;
  angleInput.value = normalizedAngle.toFixed(1);
  
  lengthInput.focus();
  inputDialog = overlay;
  
  // Hover effects
  confirmBtn.addEventListener('mouseover', () => { confirmBtn.style.background = '#106ebe'; });
  confirmBtn.addEventListener('mouseout', () => { confirmBtn.style.background = '#0078d4'; });
  cancelBtn.addEventListener('mouseover', () => { cancelBtn.style.background = '#f5f5f5'; });
  cancelBtn.addEventListener('mouseout', () => { cancelBtn.style.background = '#fafafa'; });
  
  function closeDialog() {
    if (inputDialog) {
      inputDialog.remove();
      inputDialog = null;
    }
  }
  
  async function placePointWithLength() {
    const length = parseFloat(lengthInput.value);
    const angle = parseFloat(angleInput.value);
    
    if (!length || length <= 0) {
      alert('Please enter a valid positive length');
      return;
    }
    
    if (isNaN(angle)) {
        alert('Please enter a valid angle');
        return;
    }
    
    // Convert angle to radians (standard math convention: 0° = right)
    const radians = (angle * Math.PI) / 180;
    
    // Calculate new point using angle and length
    const newX = lastPlacedPoint.x + (length * scaleX * Math.cos(radians));
    const newY = lastPlacedPoint.y - (length * scaleY * Math.sin(radians)); // Flip Y
    
    // Convert to coordinates
    const coordX = ((newX - origin.x) / scaleX).toFixed(3);
    const coordY = ((origin.y - newY) / scaleY).toFixed(3);
    
    // Place the point
    await pywebview.api.add_point(coordX, coordY, activeBundle);
    bundles[activeBundle].push([parseFloat(coordX), parseFloat(coordY)]);
    
    lastPlacedPoint = {x: newX, y: newY};
    
    animatePointPlacement(newX, newY, colors[activeBundle]);
    updateAllPoints();
    redraw();
    await updateResults();
    
    closeDialog();
  }
  
  confirmBtn.addEventListener('click', placePointWithLength);
  cancelBtn.addEventListener('click', closeDialog);
  
  // Enter key to confirm
  lengthInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') placePointWithLength();
  });
   angleInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') placePointWithLength();
  });
  
  // Escape to cancel
  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeDialog();
  });
  lengthInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { e.stopPropagation(); closeDialog(); }
  });
   angleInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { e.stopPropagation(); closeDialog(); }
  });
}

function updateAllPoints() {
  allPoints = [];
  for (let bundle in bundles) {
    bundles[bundle].forEach(([x, y], i) => {
      const canvasX = origin.x + x * scaleX;
      const canvasY = origin.y - y * scaleY;
      allPoints.push({
        x: canvasX,
        y: canvasY,
        bundle: bundle,
        index: i,
        coordX: x,
        coordY: y
      });
    });
  }
}

function findSnapPoint(mouseX, mouseY) {
  let nearest = null;
  let minDist = SNAP_RADIUS;
  
  for (let p of allPoints) {
    const dx = p.x - mouseX;
    const dy = p.y - mouseY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < minDist) {
      minDist = dist;
      nearest = p;
    }
  }
  
  return nearest;
}

function getConstrainedPoint(currentX, currentY) {
  if (!shiftKeyPressed || !lastPlacedPoint) {
    return {x: currentX, y: currentY, type: 'free'};
  }
  
  const dx = currentX - lastPlacedPoint.x;
  const dy = currentY - lastPlacedPoint.y;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  
  // If closer to horizontal, constrain to Y
  if (absDx > absDy) {
    return {x: currentX, y: lastPlacedPoint.y, type: 'horizontal'};
  } else {
    return {x: lastPlacedPoint.x, y: currentY, type: 'vertical'};
  }
}

function drawSnapIndicator() {
  if (!snapPoint) return;
  
  ctx.beginPath();
  ctx.arc(snapPoint.x, snapPoint.y, 12, 0, 2 * Math.PI);
  ctx.strokeStyle = SNAP_COLOR;
  ctx.lineWidth = 2.5;
  ctx.globalAlpha = 0.8;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc(snapPoint.x, snapPoint.y, 6, 0, 2 * Math.PI);
  ctx.fillStyle = SNAP_COLOR;
  ctx.globalAlpha = 0.3;
  ctx.fill();
  
  ctx.globalAlpha = 1;
}

function drawPreviewLine() {
  if (!lastPlacedPoint) return;
  
  const constrainedPos = getConstrainedPoint(mousePos.x, mousePos.y);
  const targetX = constrainedPos.x;
  const targetY = constrainedPos.y;
  
  // Draw preview line
  ctx.beginPath();
  ctx.moveTo(lastPlacedPoint.x, lastPlacedPoint.y);
  ctx.lineTo(targetX, targetY);
  ctx.strokeStyle = colors[activeBundle];
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.globalAlpha = 0.6;
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.setLineDash([]);
  
  // Calculate distance
  const dx = targetX - lastPlacedPoint.x;
  const dy = targetY - lastPlacedPoint.y;
  const canvasDistPx = Math.sqrt(dx * dx + dy * dy);
  const canvasDistUnits = canvasDistPx / scaleX; // Assume scaleX and scaleY are same
  
  // Draw constraint indicator if shift pressed
  if (shiftKeyPressed) {
    ctx.fillStyle = colors[activeBundle];
    ctx.font = 'bold 12px Inter, sans-serif';
    if (constrainedPos.type === 'horizontal') {
      ctx.fillText('HORIZONTAL', targetX + 10, targetY - 15);
    } else {
      ctx.fillText('VERTICAL', targetX + 10, targetY - 15);
    }
  }
  
  // Draw distance label
  const midX = (lastPlacedPoint.x + targetX) / 2;
  const midY = (lastPlacedPoint.y + targetY) / 2;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
  ctx.fillRect(midX - 35, midY - 25, 70, 24);
  
  ctx.fillStyle = colors[activeBundle];
  ctx.font = 'bold 12px Consolas, Monaco, monospace';
  ctx.textAlign = 'center';
  ctx.fillText(canvasDistUnits.toFixed(3), midX, midY - 8);
  ctx.textAlign = 'left';
}

// ===== Bundle Management =====
function setActiveBundle(bundle) {
  activeBundle = bundle;
  referencePoint = null; // Clear reference when switching bundles
  lastPlacedPoint = null; // --- NEW: Clear last point when switching bundles
  document.querySelectorAll('.bundle-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.bundle === bundle);
  });
}

// ===== Drawing Functions =====
function drawGrid() {
  ctx.strokeStyle = "#f5f5f5";
  ctx.lineWidth = 1;
  
  // Draw grid lines from origin
  for (let x = origin.x; x < canvas.width; x += scaleX) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let x = origin.x; x > 0; x -= scaleX) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = origin.y; y < canvas.height; y += scaleY) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
   for (let y = origin.y; y > 0; y -= scaleY) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
  
  ctx.strokeStyle = "#424242";
  ctx.lineWidth = 2;
  ctx.shadowColor = "rgba(0,0,0,0.1)";
  ctx.shadowBlur = 4;
  
  ctx.beginPath();
  ctx.moveTo(0, origin.y);
  ctx.lineTo(canvas.width, origin.y);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(origin.x, 0);
  ctx.lineTo(origin.x, canvas.height);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
  
  ctx.fillStyle = "#424242";
  ctx.font = "600 12px Inter, sans-serif";
  ctx.fillText("(0, 0)", origin.x + 8, origin.y - 8);
}

function getBundleCenter(points) {
    let cx = 0, cy = 0;
    points.forEach(([x, y]) => {
        cx += x;
        cy += y;
    });
    return { x: cx / points.length, y: cy / points.length };
}


function drawBundleConnections(points, color) {
  if (points.length < 2) return;
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.globalAlpha = 1;
  
  // Draw line connections between consecutive points
  for (let i = 0; i < points.length; i++) {
    const [x1, y1] = points[i];
    // Connect to next point, or wrap to first point
    const [x2, y2] = points[(i + 1) % points.length]; 
    
    // Don't draw closing line if only 2 points
    if (points.length === 2 && i === 1) continue; 
    
    const cx1 = origin.x + x1 * scaleX;
    const cy1 = origin.y - y1 * scaleY;
    const cx2 = origin.x + x2 * scaleX;
    const cy2 = origin.y - y2 * scaleY;
    
    ctx.beginPath();
    ctx.moveTo(cx1, cy1);
    ctx.lineTo(cx2, cy2);
    ctx.stroke();
    
    // Draw segment distance
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    const mx = (cx1 + cx2) / 2;
    const my = (cy1 + cy2) / 2;
    
    // Simple text background
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.font = 'bold 11px Consolas, Monaco, monospace';
    ctx.textAlign = 'center';
    const textWidth = ctx.measureText(dist.toFixed(3)).width;
    ctx.fillRect(mx - textWidth / 2 - 4, my - 10, textWidth + 8, 14);
    
    ctx.fillStyle = color;
    ctx.fillText(dist.toFixed(3), mx, my + 1);
    ctx.textAlign = 'left';
  }
  
  ctx.globalAlpha = 1;
}

function drawBundleCircle(points, color) {
  if (points.length < 2) return;
  
  const center = getBundleCenter(points);
  
  let maxR = 0;
  points.forEach(([x, y]) => {
    const dist = Math.sqrt((x - center.x) ** 2 + (y - center.y) ** 2);
    maxR = Math.max(maxR, dist);
  });
  
  const centerX = origin.x + center.x * scaleX;
  const centerY = origin.y - center.y * scaleY;
  // Use a sensible radius, e.g., max distance from center + 20%
  const radius = maxR * scaleX * 1.2; 
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.globalAlpha = 0.3;
  
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
  ctx.stroke();
  
  ctx.setLineDash([]);
  ctx.globalAlpha = 1;
}

function drawGMDLines() {
  // Get all bundles with points
  const bundlesWithPoints = Object.keys(bundles).filter(b => bundles[b].length > 0);
  
  if (bundlesWithPoints.length < 2) return;
  
  // GMD pairs to display
  const pairs = [
    ['A', 'B'],
    ['B', 'C'],
    ['A', 'C']
  ];
  
  pairs.forEach(([b1, b2]) => {
    if (bundles[b1].length > 0 && bundles[b2].length > 0) {
      // Get bundle centers
      const c1 = getBundleCenter(bundles[b1]);
      const c2 = getBundleCenter(bundles[b2]);
      
      const x1 = origin.x + c1.x * scaleX;
      const y1 = origin.y - c1.y * scaleY;
      const x2 = origin.x + c2.x * scaleX;
      const y2 = origin.y - c2.y * scaleY;
      
      // Calculate GMD (geometric mean distance between bundles)
      const dx = c2.x - c1.x;
      const dy = c2.y - c1.y;
      const gmd = Math.sqrt(dx * dx + dy * dy);
      
      const mx = (x1 + x2) / 2;
      const my = (y1 + y2) / 2;
      
      // Draw dashed line
      ctx.strokeStyle = '#FF6B35';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([5, 5]);
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.setLineDash([]);
      
      // Draw bundle center markers
      ctx.fillStyle = '#FF6B35';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(x1, y1, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x2, y2, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Draw GMD label box
      ctx.fillStyle = '#FFF5F0';
      ctx.fillRect(mx - 65, my - 20, 130, 28);
      
      ctx.strokeStyle = '#FF6B35';
      ctx.lineWidth = 2;
      ctx.strokeRect(mx - 65, my - 20, 130, 28);
      
      // GMD label text
      ctx.fillStyle = '#FF6B35';
      ctx.font = 'bold 13px Consolas, Monaco, monospace';
      ctx.textAlign = 'center';
      ctx.fillText(\`GMD \${b1}-\${b2}: \${gmd.toFixed(4)}\`, mx, my + 3);
      ctx.textAlign = 'left';
    }
  });
}

function drawPoints() {
  for (let b in bundles) {
    ctx.fillStyle = colors[b];
    bundles[b].forEach(([x, y], i) => {
      const cx = origin.x + x * scaleX;
      const cy = origin.y - y * scaleY;
      
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 2;
      
      ctx.beginPath();
      ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
      
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.beginPath();
      ctx.arc(cx - 1, cy - 1, 3, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      const label = b + (i + 1);
      ctx.font = "bold 11px Inter, sans-serif";
      const metrics = ctx.measureText(label);
      const labelWidth = metrics.width + 8;
      
      ctx.fillRect(cx + 12, cy - 16, labelWidth, 18);
      ctx.strokeStyle = colors[b];
      ctx.lineWidth = 1;
      ctx.strokeRect(cx + 12, cy - 16, labelWidth, 18);
      
      ctx.fillStyle = colors[b];
      ctx.fillText(label, cx + 16, cy - 4);
    });
  }
}

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  
  for (let b in bundles) {
    if (bundles[b].length > 0) {
      drawBundleCircle(bundles[b], colors[b]);
      drawBundleConnections(bundles[b], colors[b]);
    }
  }
  
  drawPoints();
  drawSnapIndicator();
  drawPreviewLine();
}

// ===== Animation =====
function animatePointPlacement(x, y, color) {
  let r = 0;
  const animate = () => {
    r += 3;
    if (r < 30) {
      redraw();
      
      ctx.beginPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI);
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 1 - (r / 30);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      requestAnimationFrame(animate);
    } else {
      redraw();
    }
  };
  animate();
}

// ===== Canvas Events =====
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleFactorX = canvas.width / rect.width;
  const scaleFactorY = canvas.height / rect.height;
  
  const mx = (e.clientX - rect.left) * scaleFactorX;
  const my = (e.clientY - rect.top) * scaleFactorY;
  
  mousePos = {x: mx, y: my};
  
  snapPoint = findSnapPoint(mx, my);
  
  const x = ((mx - origin.x) / scaleX).toFixed(3);
  const y = ((origin.y - my) / scaleY).toFixed(3);
  
  const display = document.getElementById('coordDisplay');
  
  if (snapPoint) {
    display.textContent = \`SNAP: \${snapPoint.bundle}\${snapPoint.index + 1} (\${snapPoint.coordX.toFixed(3)}, \${snapPoint.coordY.toFixed(3)})\`;
    display.style.background = 'rgba(255, 185, 0, 0.9)';
  } else if (lastPlacedPoint && shiftKeyPressed) {
    display.textContent = \`SHIFT: Constrained placement | x: \${x}, y: \${y}\`;
    display.style.background = 'rgba(0, 120, 212, 0.9)';
  } else {
    display.textContent = \`x: \${x}, y: \${y}\`;
    display.style.background = 'rgba(0, 0, 0, 0.85)';
  }
  display.style.opacity = '1';
  
  redraw();
});

canvas.addEventListener('click', async (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleFactorX = canvas.width / rect.width;
  const scaleFactorY = canvas.height / rect.height;
  
  const mx = (e.clientX - rect.left) * scaleFactorX;
  const my = (e.clientY - rect.top) * scaleFactorY;
  
  let finalPos;
  let x, y;
  let isSnappedToDifferentBundle = false;
  
  if (snapPoint) {
    x = snapPoint.coordX.toFixed(3);
    y = snapPoint.coordY.toFixed(3);
    finalPos = {x: snapPoint.x, y: snapPoint.y};
    
    // Check if we're snapping to a different bundle
    if (snapPoint.bundle !== activeBundle) {
      isSnappedToDifferentBundle = true;
    }
  } else {
    const constrainedPos = getConstrainedPoint(mx, my);
    x = ((constrainedPos.x - origin.x) / scaleX).toFixed(3);
    y = ((origin.y - constrainedPos.y) / scaleY).toFixed(3);
    finalPos = {x: constrainedPos.x, y: constrainedPos.y};
  }
  
  // Check if this is the first point of the current bundle
  const isFirstPoint = bundles[activeBundle].length === 0;
  
  // If this is the first point and snapped to different bundle, mark as reference
  if (isFirstPoint && isSnappedToDifferentBundle) {
    referencePoint = {
      x: parseFloat(x),
      y: parseFloat(y),
      bundle: activeBundle
    };
  }
  
  // If this is the second point and we have a reference point, delete the first
  if (bundles[activeBundle].length === 1 && referencePoint && referencePoint.bundle === activeBundle) {
    // Remove the reference point from backend and frontend
    bundles[activeBundle].shift(); // Remove first element
    await pywebview.api.clear_bundle(activeBundle);
    
    // Re-add all remaining points (none in this case since we just removed the only one)
    for (let point of bundles[activeBundle]) {
      await pywebview.api.add_point(point[0], point[1], activeBundle);
    }
    
    referencePoint = null; // Clear reference
  }
  
  await pywebview.api.add_point(x, y, activeBundle);
  bundles[activeBundle].push([parseFloat(x), parseFloat(y)]);
  
  lastPlacedPoint = finalPos;
  
  animatePointPlacement(finalPos.x, finalPos.y, colors[activeBundle]);
  updateAllPoints();
  redraw();
  await updateResults();
});

canvas.addEventListener('mouseleave', () => {
  snapPoint = null;
  document.getElementById('coordDisplay').style.opacity = '0';
});


// ===== Results Display =====
async function updateResults() {
  const results = await pywebview.api.compute_results();
  const container = document.getElementById('results');
  
  if (!results || (!results.gmr || results.gmr.length === 0) && (!results.gmd || results.gmd.length === 0)) {
    container.innerHTML = \`
      <div class="empty-state">
        <svg class="empty-icon" fill="currentColor" viewBox="0 0 20 20">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12z"/>
        </svg>
        <p class="empty-text">Click on the canvas to place conductor points • Hold SHIFT for 90° constraints</p>
      </div>\`;
    return;
  }
  
  let html = '';
  
  if (results.gmr && results.gmr.length > 0) {
    html += '<div class="result-card"><div class="result-card-title">Geometric Mean Radius (GMR)</div>';
    results.gmr.forEach(r => {
      html += \`
        <div class="result-item">
          <span class="result-label">
            <span class="bundle-badge" style="background:\${colors[r.label]}"></span>
            Bundle \${r.label} <span style="opacity:0.6; font-size:11px;">(\${r.count} conductor\${r.count>1?'s':''})</span>
          </span>
          <span class="result-value">\${r.value.toFixed(6)} m</span>
        </div>\`;
    });
    html += '</div>';
  }
  
  if (results.gmd && results.gmd.length > 0) {
    html += '<div class="result-card"><div class="result-card-title">Geometric Mean Distance (GMD)</div>';
    results.gmd.forEach(r => {
      html += \`
        <div class="result-item">
          <span class="result-label">Distance \${r.pair}</span>
          <span class="result-value">\${r.value.toFixed(6)} m</span>
        </div>\`;
    });
    html += '</div>';
  }
  
  if (results.params && Object.keys(results.params).length > 0) {
    const p = results.params;
    
    html += '<div class="result-card"><div class="result-card-title">Resistance</div>';
    html += \`
      <div class="result-item">
        <span class="result-label">R per km</span>
        <span class="result-value">\${p.R_per_km.toFixed(6)} Ω/km</span>
      </div>
      <div class="result-item param-highlight">
        <span class="result-label">Total Resistance</span>
        <span class="result-value">\${p.R_total.toFixed(4)} Ω</span>
      </div>\`;
    html += '</div>';
    
    html += '<div class="result-card"><div class="result-card-title">Inductance</div>';
    html += \`
      <div class="result-item">
        <span class="result-label">L per km</span>
        <span class="result-value">\${p.L_per_km.toFixed(6)} mH/km</span>
      </div>
      <div class="result-item param-highlight">
        <span class="result-label">Total Inductance</span>
        <span class="result-value">\${p.L_total.toFixed(4)} mH</span>
      </div>
      <div class="result-item">
        <span class="result-label">Inductive Reactance (X<sub>L</sub>)</span>
        <span class="result-value">\${p.XL.toFixed(4)} Ω</span>
      </div>\`;
    html += '</div>';
    
    html += '<div class="result-card"><div class="result-card-title">Capacitance</div>';
    html += \`
      <div class."result-item">
        <span class="result-label">C per km</span>
        <span class="result-value">\${p.C_per_km.toFixed(6)} nF/km</span>
      </div>
      <div class="result-item param-highlight">
        <span class="result-label">Total Capacitance</span>
        <span class="result-value">\${p.C_total.toFixed(4)} µF</span>
      </div>
      <div class="result-item">
        <span class="result-label">Capacitive Reactance (X<sub>C</sub>)</span>
        <span class="result-value">\${p.XC.toFixed(4)} Ω</span>
      </div>\`;
    html += '</div>';
  }
  
  container.innerHTML = html;
}

// ===== Control Functions =====
async function setGMRs() {
  const A = document.getElementById('gA').value;
  const B = document.getElementById('gB').value;
  const C = document.getElementById('gC').value;
  await pywebview.api.set_gmr("A", A);
  await pywebview.api.set_gmr("B", B);
  await pywebview.api.set_gmr("C", C);
  await updateResults();
}

async function updateUnit() {
  const u = document.getElementById('unit').value;
  await pywebview.api.set_unit(u);
  // --- NEW: When unit changes, we must reset GMRs
  await setGMRs();
}

async function updateScale() {
  const sx = document.getElementById('scaleX').value;
  const sy = document.getElementById('scaleY').value;
  await pywebview.api.set_scale(sx, sy);
  scaleX = parseFloat(sx);
  scaleY = parseFloat(sy);
  updateAllPoints();
  redraw();
}

async function updateLineParams() {
  const material = document.getElementById('material').value;
  const length = document.getElementById('length').value;
  const radius = document.getElementById('radius').value;
  const freq = document.getElementById('freq').value;
  
  await pywebview.api.set_line_params(material, length, radius, freq);
  
  // --- NEW: Sync GMR boxes with new radius
  // The radius is in meters, convert it to current selected unit
  const currentUnit = document.getElementById('unit').value;
  const conversionFactor = ${JSON.stringify(UNIT_CONVERSIONS)}[currentUnit];
  if (conversionFactor > 0) {
    const radiusInCurrentUnits = parseFloat(radius) / conversionFactor;
    document.getElementById('gA').value = radiusInCurrentUnits.toFixed(4);
    document.getElementById('gB').value = radiusInCurrentUnits.toFixed(4);
    document.getElementById('gC').value = radiusInCurrentUnits.toFixed(4);
  }
  
  // --- NEW: Propagate this change to the backend's r' values
  await setGMRs(); 
  
  // updateResults() is already called by setGMRs()
}

async function clearCurrent() {
  await pywebview.api.clear_bundle(activeBundle);
  bundles[activeBundle] = [];
  lastPlacedPoint = null;
  referencePoint = null; // Clear reference when clearing bundle
  updateAllPoints();
  redraw();
  await updateResults();
}

async function clearAll() {
  await pywebview.api.clear_all();
  bundles = {A: [], B: [], C: []};
  lastPlacedPoint = null;
  referencePoint = null; // Clear reference when clearing all
  updateAllPoints();
  redraw();
  await updateResults();
}
// ===== LaTeX Export =====
let currentLatexContent = null;

async function exportLatex() {
  const apiKey = document.getElementById('apiKey').value;
  const statusDiv = document.getElementById('exportStatus');
  
  if (!apiKey) {
    statusDiv.style.color = '#d13438';
    statusDiv.textContent = '⚠️ Please enter your Gemini API key';
    return;
  }
  
  // Show loading modal
  showLoadingModal();
  
  try {
    const latex = await pywebview.api.export_latex_solution(apiKey);
    
    closeLoadingModal();
    
    if (latex.startsWith('Error')) {
      showResultModal('error', 'Generation Failed', latex);
    } else {
      showLatexModal(latex);
    }
  } catch (error) {
    closeLoadingModal();
    showResultModal('error', 'Export Failed', error.toString());
  }
}

function showLoadingModal() {
  const modal = document.createElement('div');
  modal.id = 'export-loading-modal';
  modal.style.cssText = \`
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
  \`;
  
  modal.innerHTML = \`
    <div style="
      background: white;
      border-radius: 12px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 400px;
      animation: modalFadeIn 0.3s ease;
    ">
      <div style="
        width: 60px;
        height: 60px;
        border: 4px solid #e1dfdd;
        border-top-color: #0078d4;
        border-radius: 50%;
        margin: 0 auto 24px;
        animation: spin 1s linear infinite;
      "></div>
      
      <h3 style="
        font-size: 18px;
        font-weight: 600;
        color: #1f1f1f;
        margin-bottom: 12px;
      ">Generating LaTeX Solution</h3>
      
      <p style="
        font-size: 14px;
        color: #605e5c;
        line-height: 1.6;
      ">Please wait while Gemini AI creates your detailed step-by-step solution document...</p>
      
      <div style="
        margin-top: 20px;
        padding: 12px;
        background: #f3f3f3;
        border-radius: 6px;
        font-size: 12px;
        color: #605e5c;
      ">⏱️ This usually takes 5-15 seconds</div>
    </div>
  \`;
  
  document.body.appendChild(modal);
}

function closeLoadingModal() {
  const modal = document.getElementById('export-loading-modal');
  if (modal) {
    modal.style.animation = 'modalFadeOut 0.3s ease';
    setTimeout(() => modal.remove(), 300);
  }
}

function showResultModal(type, title, message) {
  const isSuccess = type === 'success';
  const icon = isSuccess ? '✅' : '❌';
  const color = isSuccess ? '#107c10' : '#d13438';
  
  const modal = document.createElement('div');
  modal.id = 'export-result-modal';
  modal.style.cssText = \`
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
    animation: modalFadeIn 0.3s ease;
  \`;
  
  modal.innerHTML = \`
    <div style="
      background: white;
      border-radius: 12px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 450px;
      animation: modalFadeIn 0.3s ease;
    ">
      <div style="
        font-size: 48px;
        margin-bottom: 20px;
      ">\${icon}</div>
      
      <h3 style="
        font-size: 20px;
        font-weight: 600;
        color: \${color};
        margin-bottom: 16px;
      ">\${title}</h3>
      
      <p style="
        font-size: 14px;
        color: #605e5c;
        line-height: 1.6;
        margin-bottom: 24px;
        max-height: 200px; 
        overflow-y: auto;
        text-align: left;
      ">\${message}</p>
      
      <button onclick="closeResultModal()" style="
        padding: 12px 32px;
        background: \${color};
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
      " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
        Close
      </button>
    </div>
  \`;
  
  document.body.appendChild(modal);
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeResultModal();
    }
  });
}

function closeResultModal() {
  const modal = document.getElementById('export-result-modal');
  if (modal) {
    modal.style.animation = 'modalFadeOut 0.3s ease';
    setTimeout(() => modal.remove(), 300);
  }
}

function showLatexModal(latexContent) {
  currentLatexContent = latexContent;
  
  const modal = document.createElement('div');
  modal.id = 'latex-display-modal';
  modal.style.cssText = \`
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
    animation: modalFadeIn 0.3s ease;
  \`;
  
  modal.innerHTML = \`
    <div style="
      background: white;
      border-radius: 12px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 900px;
      width: 90%;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      animation: modalFadeIn 0.3s ease;
    ">
      <div style="
        padding: 24px 32px;
        border-bottom: 1px solid #e1dfdd;
        display: flex;
        align-items: center;
        justify-content: space-between;
      ">
        <div>
          <h3 style="
            font-size: 20px;
            font-weight: 600;
            color: #1f1f1f;
            margin-bottom: 4px;
          ">✅ LaTeX Solution Generated</h3>
          <p style="
            font-size: 13px;
            color: #605e5c;
          ">Review the code below or export it as a PDF.</p>
        </div>
        <button class="close-latex-btn" style="
          width: 32px;
          height: 32px;
          border: none;
          background: transparent;
          color: #605e5c;
          font-size: 24px;
          cursor: pointer;
          border-radius: 4px;
          transition: all 0.15s ease;
          line-height: 1;
        " onmouseover="this.style.background='#f3f3f3'" onmouseout="this.style.background='transparent'">×</button>
      </div>
      
      <div style="
        flex: 1;
        overflow: hidden;
        padding: 24px 32px;
        background: #f9f9f9;
        display: flex;
        flex-direction: column;
      ">
        <textarea id="latex-content-textarea" readonly style="
          flex: 1;
          background: white;
          color: #1f1f1f;
          padding: 20px;
          border: 1px solid #e1dfdd;
          border-radius: 8px;
          font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
          font-size: 13px;
          line-height: 1.6;
          resize: none;
          outline: none;
          cursor: text;
          overflow-y: auto;
        ">\${latexContent}</textarea>
      </div>
      
      <div style="
        padding: 20px 32px;
        border-top: 1px solid #e1dfdd;
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      ">
        <button class="copy-latex-btn" style="
          padding: 10px 24px;
          background: #107c10;
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
          display: flex;
          align-items: center;
          gap: 8px;
        " onmouseover="this.style.background='#0e6b0e'" onmouseout="this.style.background='#107c10'">
          📄 Copy to Clipboard
        </button>
        
        <button class="export-pdf-btn" style="
          padding: 10px 24px;
          background: #d83b01;
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
          display: flex;
          align-items: center;
          gap: 8px;
        " onmouseover="this.style.background='#c43501'" onmouseout="this.style.background='#d83b01'">
          📑 Export as PDF
        </button>
        
        <button class="download-latex-btn" style="
          padding: 10px 24px;
          background: #0078d4;
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
          display: flex;
          align-items: center;
          gap: 8px;
        " onmouseover="this.style.background='#106ebe'" onmouseout="this.style.background='#0078d4'">
          💾 Download .tex
        </button>

        
        
        <button class="close-latex-btn2" style="
          padding: 10px 24px;
          background: #fafafa;
          color: #1f1f1f;
          border: 1px solid #e1dfdd;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
        " onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#fafafa'">
          Close
        </button>
      </div>
    </div>
  \`;
  
  document.body.appendChild(modal);
  
  // Get textarea element
  const textarea = document.getElementById('latex-content-textarea');
  
  // Add event listeners
  modal.querySelector('.close-latex-btn').addEventListener('click', closeLatexModal);
  modal.querySelector('.close-latex-btn2').addEventListener('click', closeLatexModal);
  
  modal.querySelector('.copy-latex-btn').addEventListener('click', function() {
    textarea.select();
    textarea.setSelectionRange(0, textarea.value.length);
    
    try {
      // Method 1: Modern clipboard API
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(currentLatexContent).then(() => {
          showCopySuccess(this, '✅ Copied!');
        }).catch(() => {
          // Fallback to execCommand
          document.execCommand('copy');
          showCopySuccess(this, '✅ Copied!');
        });
      } else {
        // Method 2: Old school execCommand
        document.execCommand('copy');
        showCopySuccess(this, '✅ Copied!');
      }
    } catch (err) {
      alert('Failed to copy: ' + err.message);
    }
  });
  
  modal.querySelector('.download-latex-btn').addEventListener('click', function() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = \`transmission_line_solution_\${timestamp}.tex\`;
    
    const blob = new Blob([currentLatexContent], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    
    showCopySuccess(this, '✅ Downloaded!');
  });

  modal.querySelector('.export-pdf-btn').addEventListener('click', async function() {
      // --- NEW: PDF Export ---
      closeLatexModal(); // Close this modal first
      showLoadingModal(); // Show "compiling" modal
      
      try {
        const result = await pywebview.api.generate_pdf_from_latex(currentLatexContent);
        closeLoadingModal();
        if (result.success) {
            showResultModal('success', 'PDF Saved', \`Successfully saved PDF to: <br><b>\${result.path}</b>\`);
        } else {
            showResultModal('error', 'PDF Export Failed', result.error);
        }
    } catch (error) {
        closeLoadingModal();
        showResultModal('error', 'PDF Export Failed', error.toString());
    }
  });
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeLatexModal();
    }
  });
  
  // Close on ESC key
  const escHandler = (e) => {
    if (e.key === 'Escape') {
      closeLatexModal();
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);
  
  // Focus textarea and position cursor at start
  setTimeout(() => {
    textarea.focus();
    textarea.setSelectionRange(0, 0);
  }, 100);
}

function showCopySuccess(btn, text) {
  const originalText = btn.innerHTML;
  const originalBg = btn.style.background;
  btn.innerHTML = text;
  
  setTimeout(() => {
    btn.innerHTML = originalText;
    btn.style.background = originalBg;
  }, 2000);
}

function closeLatexModal() {
  const modal = document.getElementById('latex-display-modal');
  if (modal) {
    modal.style.animation = 'modalFadeOut 0.3s ease';
    setTimeout(() => modal.remove(), 300);
  }
  // Keep currentLatexContent for PDF export
}

// --- NEW: Panel Resize Functionality ---
let isResizing = false;
let currentResizer = null;

document.querySelectorAll('.resizer').forEach(resizer => {
  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    currentResizer = resizer;
    document.body.classList.add('resizing');
    // Prevent text selection during drag
    e.preventDefault(); 
  });
});

document.addEventListener('mousemove', (e) => {
  if (!isResizing) return;
  
  const leftPanel = document.getElementById('leftPanel');
  const rightPanel = document.getElementById('rightPanel');
  const minPanelWidth = 300; // Min width for side panels
  const minCanvasWidth = 400; // Min width for center canvas

  if (currentResizer.id === 'leftResizer') {
    const newLeftWidth = e.clientX;
    if (newLeftWidth > minPanelWidth && window.innerWidth - newLeftWidth - rightPanel.offsetWidth > minCanvasWidth) {
      leftPanel.style.width = newLeftWidth + 'px';
    }
  } else if (currentResizer.id === 'rightResizer') {
    const newRightWidth = window.innerWidth - e.clientX;
    if (newRightWidth > minPanelWidth && window.innerWidth - newRightWidth - leftPanel.offsetWidth > minCanvasWidth) {
      rightPanel.style.width = newRightWidth + 'px';
    }
  }
});

document.addEventListener('mouseup', () => {
  isResizing = false;
  currentResizer = null;
  document.body.classList.remove('resizing');
});


// ===== Initialize =====
redraw();
</script>
</body>
</html>
"""

# ---------- Run ----------
if __name__ == "__main__":
    api = GMDGMRApp()
    webview.create_window(
        "Transmission Line Calculator", 
        html=html, 
        js_api=api, 
        width=1600, 
        height=900,
        resizable=True
    )
    webview.start()