import numpy as np
import webview
from itertools import combinations, product

# ---------- Unit & Material Data ----------
UNIT_CONVERSIONS = {"m": 1.0, "ft": 0.3048, "inch": 0.0254, "cm": 0.01, "mm": 0.001}
MATERIALS = {"Copper": 1.68e-8, "Aluminum": 2.82e-8, "Steel": 1.43e-7, "ACSR": 3.2e-8}

# ---------- Math Utilities ----------
def distance(p1, p2):
    return np.linalg.norm(np.array(p1) - np.array(p2))

def geometric_mean(values):
    return np.prod(values) ** (1 / len(values))

def compute_gmr(bundle_points, r_self):
    n = len(bundle_points)
    if n == 1: return r_self
    distances = [distance(p1, p2) for p1, p2 in combinations(bundle_points, 2)]
    all_terms = [r_self] * n + distances
    return np.prod(all_terms) ** (1 / n)

def compute_gmd(bundle1, bundle2):
    distances = [distance(p1, p2) for p1, p2 in product(bundle1, bundle2)]
    return geometric_mean(distances)

# ---------- App Logic ----------
class GMDGMRApp:
    def __init__(self):
        self.bundles = {"A": [], "B": [], "C": []}
        self.r_self = {"A": 0.01, "B": 0.01, "C": 0.01}
        self.unit = "m"
        self.scale_x = 40
        self.scale_y = 40
        self.material = "Copper"
        self.length = 100.0
        self.conductor_radius = 0.01
        self.freq = 60.0
        self.snap_enabled = False
        self.snap_tolerance = 0.5

    def set_snap(self, enabled):
        self.snap_enabled = enabled
        return "Snap enabled" if enabled else "Snap disabled"

    def get_snap_point(self, x, y):
        if not self.snap_enabled:
            return None
        x, y = float(x), float(y)
        # Snap to nearest integer
        snapped_x = round(x)
        snapped_y = round(y)
        return {"x": snapped_x, "y": snapped_y}

    def set_unit(self, u):
        self.unit = u
        return f"Units: {u}"

    def set_scale(self, sx, sy):
        self.scale_x, self.scale_y = float(sx), float(sy)
        return "Scale updated"

    def set_gmr(self, bundle, val):
        self.r_self[bundle] = float(val) * UNIT_CONVERSIONS[self.unit]
        return f"GMR {bundle} set"

    def set_line_params(self, material, length, radius, freq):
        self.material, self.length, self.conductor_radius, self.freq = material, float(length), float(radius), float(freq)
        return "Params updated"

    def add_point(self, x, y, bundle):
        x_m = float(x) * UNIT_CONVERSIONS[self.unit]
        y_m = float(y) * UNIT_CONVERSIONS[self.unit]
        self.bundles[bundle].append((x_m, y_m))
        return "ok"

    def clear_bundle(self, bundle):
        self.bundles[bundle] = []
        return f"Cleared {bundle}"

    def clear_all(self):
        self.bundles = {"A": [], "B": [], "C": []}
        return "All cleared"

    def compute_results(self):
        results = {"gmr": [], "gmd": [], "params": {}}
        gmr_values = {}
        
        for label, points in self.bundles.items():
            if points:
                gmr_values[label] = compute_gmr(points, self.r_self[label])
                results["gmr"].append({"label": label, "value": gmr_values[label], "count": len(points)})
        
        gmd_values = {}
        for (a, b) in combinations(self.bundles.keys(), 2):
            if self.bundles[a] and self.bundles[b]:
                gmd = compute_gmd(self.bundles[a], self.bundles[b])
                gmd_values[f"{a}-{b}"] = gmd
                results["gmd"].append({"pair": f"{a}-{b}", "value": gmd})
        
        if len(gmr_values) >= 1:
            rho = MATERIALS.get(self.material, 1.68e-8)
            area = np.pi * (self.conductor_radius ** 2)
            n_conductors = max(len(self.bundles[b]) for b in self.bundles if self.bundles[b])
            R_per_km = (rho * 1000) / (area * n_conductors) if n_conductors > 0 else 0
            R_total = R_per_km * self.length
            
            
            
            omega = 2 * np.pi * self.freq
            XL = omega * L_total if L_total > 0 else 0
            XC = (1 / (omega * C_total)) if C_total > 0 else 0
            
            results["params"] = {
                "R_per_km": R_per_km, "R_total": R_total,
                "XL": XL, "XC": XC
            }
        
        return results